---
layout: post
title: "VUE项目多语言全自动生成维护工具"
categories: 工具
tags: 开发便捷工具
author: fengsh998
typora-root-url: ..
---

工具作用：
将csv文档读取转为对应的i18n语种。然而为什么选cvs而不用excel，因为git能跟踪cvs的修改及冲突记录，而excel不能，因此工具最终选取读取cvs进行生成对应的语种。

如果有需要读取excel 则需要引入库： 
openpyxl 是读写Excel xlsx/xlsm/xltx/xltm 文件（即 Office 2007 及以上版本的 Excel 文件）的 Python 库。

CSV文档样式：

![img](/assets/articles/tools/tool-vue-cvs.jpg)

(MacOs)安装基本的环境：

```shell
//会在当前目录下创建一个名为 venv 的虚拟环境
python3 -m venv venv
//激活虚拟环境
source venv/bin/activate
pip install openpyxl
```

csv_to_json_multilevel_array_v2.py
```python
"""
csv_to_json_multilevel_array_v2.py

多语言CSV转嵌套JSON/JS工具

示例用法：

默认（value为空不输出key）
python3 csv_to_json_multilevel_array_v2.py lang.csv ./output/ [--ext js/json]

value为空填''（空字符串）：
python3 csv_to_json_multilevel_array_v2.py lang.csv ./output/ --fill-empty

只输出第1、3、5列（索引从0开始，0为keypath）：
python3 csv_to_json_multilevel_array_v2.py lang.csv ./output/ --only-indices 1,3,5

输出为js格式：
python3 csv_to_json_multilevel_array_v2.py lang.csv ./output/ --ext js

js格式key不加引号：
python3 csv_to_json_multilevel_array_v2.py lang.csv ./output/ --ext js --no-quotes-key

"""

import os
import json
import sys
import re
import csv

__version__ = "1.1.0"

def parse_key_path(key_path):
    """
    支持带数组下标的key path解析，例如 a.b[0].c => ['a', 'b', 0, 'c']
    """
    parts = []
    regex = re.compile(r'([^\[\].]+)(\[\d+\])*')
    for segment in key_path.split('.'):
        matches = list(regex.finditer(segment))
        for m in matches:
            key = m.group(1)
            if key:
                parts.append(key)
            index_str = m.group(0)[len(key):]
            for idx in re.findall(r'\[(\d+)\]', index_str):
                parts.append(int(idx))
    return parts

def set_nested(d, key_path, value):
    """
    根据复杂key_path设置嵌套dict/array
    """
    keys = parse_key_path(key_path)
    cur = d
    for i, k in enumerate(keys):
        if i == len(keys) - 1:
            cur[k] = value
        else:
            next_k = keys[i+1]
            if isinstance(k, int):
                if not isinstance(cur, list):
                    cur_parent = cur
                    cur = []
                    for pk, pv in cur_parent.items():
                        if pv == cur_parent:
                            cur_parent[pk] = cur
                while len(cur) <= k:
                    cur.append({})
                if isinstance(next_k, int):
                    if not isinstance(cur[k], list):
                        cur[k] = []
                elif not isinstance(cur[k], dict):
                    cur[k] = {}
                cur = cur[k]
            else:
                if isinstance(cur, list):
                    temp = cur
                    cur = {}
                    for idx, item in enumerate(temp):
                        if item == cur:
                            temp[idx] = cur
                if k not in cur or not isinstance(cur[k], (dict, list)):
                    if isinstance(next_k, int):
                        cur[k] = []
                    else:
                        cur[k] = {}
                cur = cur[k]

def dict_to_js(obj, indent=2, level=0, no_quotes_key=False):
    """
    转换dict为js对象字符串，支持key不加引号
    """
    pad = ' ' * (indent * level)
    if isinstance(obj, dict):
        items = []
        for k, v in obj.items():
            if no_quotes_key and re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', str(k)):
                key_repr = str(k)
            else:
                key_repr = json.dumps(str(k), ensure_ascii=False)
            js_v = dict_to_js(v, indent, level + 1, no_quotes_key)
            items.append(f"{pad}{' ' * indent}{key_repr}: {js_v}")
        if items:
            return "{\n" + ",\n".join(items) + f"\n{pad}" + "}"
        else:
            return "{}"
    elif isinstance(obj, list):
        if not obj:
            return "[]"
        items = [dict_to_js(i, indent, level + 1, no_quotes_key) for i in obj]
        return "[\n" + ",\n".join([pad + ' ' * indent + e for e in items]) + f"\n{pad}]"
    else:
        return json.dumps(obj, ensure_ascii=False)

def csv_to_json_files(
        csv_path, output_dir, output_ext='json',
        fill_empty_value=False, only_indices=None, no_quotes_key=False
    ):
    """
    读取csv文件，根据第一列的keypath，生成多份json/js文件
    :param csv_path: csv文件路径
    :param output_dir: 输出json文件目录
    :param output_ext: 'json' 或 'js'
    :param fill_empty_value: True则value没内容时填''，否则不输出该key
    :param only_indices: 指定只导出的列（索引从0开始，0是keypath），如[1,3,5]
    :param no_quotes_key: 输出js时key不加引号
    """
    # 自动尝试 utf-8-sig 和 utf-8
    try:
        with open(csv_path, encoding="utf-8-sig") as f:
            reader = csv.reader(f)
            rows = list(reader)
    except UnicodeDecodeError:
        with open(csv_path, encoding="utf-8") as f:
            reader = csv.reader(f)
            rows = list(reader)

    if not rows or len(rows[0]) < 2:
        print("表头列小于2，无法生成json文件")
        return

    headers = rows[0]
    key_col = 0  # 第一列作为key
    lang_cols = range(1, len(headers))
    # 处理只输出指定列
    if only_indices:
        output_cols = only_indices
    else:
        output_cols = lang_cols

    # 映射索引到表头
    header_map = {i: headers[i] for i in output_cols}

    lang_dicts = {header_map[i]: {} for i in output_cols}

    for row in rows[1:]:
        if len(row) <= key_col:
            continue
        key = row[key_col]
        if not key:
            continue
        for i in output_cols:
            val = row[i] if i < len(row) else None
            lang = header_map[i]
            # 空值处理
            if val is not None and str(val).strip() != "":
                set_nested(lang_dicts[lang], key, val)
            elif fill_empty_value:
                set_nested(lang_dicts[lang], key, "")

    os.makedirs(output_dir, exist_ok=True)
    for lang, mapping in lang_dicts.items():
        filename = os.path.join(output_dir, f"{lang}.{output_ext}")
        with open(filename, "w", encoding="utf-8") as f:
            if output_ext == 'json':
                json.dump(mapping, f, ensure_ascii=False, indent=2)
            elif output_ext == 'js':
                f.write(f"export const messages = ")
                if no_quotes_key:
                    f.write(dict_to_js(mapping, indent=2, no_quotes_key=True))
                else:
                    json.dump(mapping, f, ensure_ascii=False, indent=2)
                f.write(";")
            else:
                raise ValueError("只支持输出 json 或 js")
        print(f"已生成: {filename}")

def print_version():
    print(f"version: {__version__}")

def print_help():
    help_text = f"""
version: v{__version__}
------------------------------------------
多语言CSV转嵌套JSON/JS工具

用法：
  ./languageTool <输入csv路径> <输出目录> [选项]

作者: fengsh998@163.com

选项说明：
  --ext js|json         输出文件格式，默认json
  --fill-empty          value为空时填充空字符串，否则不输出该key
  --only-indices 1,3,5  只导出指定索引列（逗号分隔，索引从0开始，0为keypath，常用如1,2,3...）
  --no-quotes-key       js格式时对象的key不加引号（仅js有效，json始终加引号）
  -h, --help            显示帮助信息
  -v, --version         显示版本号

示例：
  默认（value为空不输出key）：
    ./languageTool lang.csv ./output/

  value为空填''（空字符串）：
    ./languageTool lang.csv ./output/ --fill-empty

  只输出第1、3、5列（索引从0开始，0为keypath）：
    ./languageTool lang.csv ./output/ --only-indices 1,3,5

  输出为js格式：
    ./languageTool lang.csv ./output/ --ext js

  js格式key不加引号：
    ./languageTool lang.csv ./output/ --ext js --no-quotes-key

  查看版本号：
    ./languageTool --version
------------------------------------------
"""
    print(help_text)

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(
        description="将多语言CSV转为嵌套JSON或JS",
        add_help=False
    )
    parser.add_argument("csv_path", nargs="?", help="csv文件路径")
    parser.add_argument("output_dir", nargs="?", help="输出目录")
    parser.add_argument("--ext", choices=['json', 'js'], default='json', help="输出文件扩展名（json或js）")
    parser.add_argument("--fill-empty", action="store_true", help="未填写value时填充空字符串")
    parser.add_argument("--only-indices", help="仅导出指定索引列（逗号分隔, 例如 1,3,5）,索引从0开始，0为keypath")
    parser.add_argument("--no-quotes-key", action="store_true", help="js格式对象key不加引号")
    parser.add_argument("-v", "--version", action="store_true", help="显示版本号")
    parser.add_argument("-h", "--help", action="store_true", help="显示帮助信息")
    args = parser.parse_args()

    if args.version:
        print_version()
        sys.exit(0)
    if args.help or not args.csv_path or not args.output_dir:
        print_help()
        sys.exit(0)

    only_indices = None
    if args.only_indices:
        only_indices = [int(i) for i in args.only_indices.split(',') if i.strip().isdigit()]
        only_indices = [i for i in only_indices if i != 0]

    csv_to_json_files(
        args.csv_path,
        args.output_dir,
        args.ext,
        fill_empty_value=args.fill_empty,
        only_indices=only_indices,
        no_quotes_key=args.no_quotes_key
    )
```

将py脚本打包成可执行文件：

跨平台执行文件制作：

> 安装：pip install pyinstaller
{: .prompt-tip }

执行打包命令

```shell
#打包前
rm -rf build dist __pycache__ *.spec

#使用venv虚拟环境
python -m PyInstaller --onefile --name languageTool excel_to_json_multilevel_array_v2.py

#--onefile 选项会生成一个独立的单文件可执行程序。
#打包完成后，生成的可执行文件在 dist 目录下。
```

如果不同系统下运行的工具，需要在不同的操作系统下安装python环境并打包出对应的工具才能在相应的系统下运行

把打包好的languageTool copy到Vue项目的根目录下，执行：

<div style="background-color:#9d9d9d;padding:10px;border-radius:5px;">
    <p>cd your-vue-dir</p>
    chmod +x languageTool
</div>

以上可以通过命令行的方式来测试工具的运行后效果。

> ldd --version 检查当前系统的 glibc 版本 如输出：ldd (GNU libc) 2.32
> 
> ldd languageTool 查看打好的包的动态库依赖。
{: .prompt-tip }


以下是将工具集成到VUE项目并实现自动生成i18n的语言文档，同时支持CSV修改实时热更新。

需要安装：

```shell
npm install --save-dev concurrently
npm install --save-dev chokidar-cli
```

修改package.json中的scripts部分

```json
....
"scripts": {
    ...
    "dev-hot": "concurrently \"npm:watch:xlsx\" \"vite\"",
    ...
    "generateLanguage": "sh ./autolang.sh",
    "postinstall": "npm run generateLanguage", #npm install勾子。
    "watch:xlsx": "node watch-xlsx.js" #热更新监听
  },
....
```

执行npm run dev-hot 后前端运行起来，然后只要csv文件有修改就会重被监听到。

autolang.sh

```shell
echo "--------开始自动化生成语言------"

chmod +x ./languageTool
chmod +x ./languageTool_linux

OS_TYPE=$(uname)
echo "操作系统类型: $OS_TYPE"
case "$OS_TYPE" in
    Linux*)
        ./ubuntTool language.csv ./src/lang/ --ext js --no-quotes-key
        ;;
    Darwin*)
        ./languageTool language.csv ./src/lang/ --ext js --no-quotes-key
        ;;
    CYGWIN*|MINGW*|MSYS*)
        echo "检测到 Windows (Cygwin/MinGW/MSYS) 环境"
        # 在 Windows 下可能需要调整路径或使用不同的执行方式
        # 例如，如果 languageTool 是 .exe 文件，可能需要直接调用
        # 或者使用 wine 运行
        ;;
    *)
        echo "未知的操作系统类型: $OS_TYPE"
        exit 1
        ;;
esac

#./languageTool language.csv ./output/ --ext js
echo "------------生成完毕----------"
```

watch-xlsx.js

```javascript
import chokidar from "chokidar";
import { exec } from "child_process";

const watcher = chokidar.watch("./*.xlsx");
watcher.on("change", (file) => {
    console.log(`${file} changed, running autolang.sh ...`);
    exec("sh ./autolang.sh", (err, stdout, stderr) => {
        if (err) console.error(stderr);
        else console.log(stdout);
    });
});
```

![img](/assets/articles/tools/tool-vue.jpg)

![img](/assets/articles/tools/tool-vue-2.jpg)

总结：
原理就是监听文件变化然后执行脚本，运行工具重新生成。
