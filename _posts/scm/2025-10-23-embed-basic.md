---
layout: post
title: "嵌入式-基础知识"
categories: 嵌入式
tags: 嵌入式
author: fengsh998
typora-root-url: ..
---

## 位运算

            高位      <----------                低位
    十进制   亿 仟万 佰万 十万 万 仟 百 十 个 十分位，百分位
    
            高位  <----  低位
    二进制   1 1 1 0 0 0 1 0
    
    

**因为采用的是位运算，所以无论是16进制还是10进制都被隐式的转为二进制进行计算。**

**"|"** : 或运算, 只有有一个为1，则结果为1

| 真值表 |
|---|
|0 \| 0 = 0|
|0 \| 1 = 1|
|1 \| 0 = 1|
|1 \| 1 = 1|

eg: 0x1A | 0x3C = 0x3E 

        0x1A =  0001 1010
    |   0x3C =  0011 1100
    --------------------------
                0011 1110 == 0x3E 



**"&"** : 与运算, 只有同时为1，结果才为1

| 真值表 |
|---|
|0 \| 0 = 0|
|0 \| 1 = 0|
|1 \| 0 = 0|
|1 \| 1 = 1|

eg: 0x1A & 0x3C = 0x18

        0x1A = 0001 1010
    &   0x3C = 0011 1100
    --------------------------
               0001 1000 == 0x18

**"^"** : 异或运算，相同为0，不同为1

| 真值表 |
|---|
|0 \| 0 = 0|
|0 \| 1 = 1|
|1 \| 0 = 1|
|1 \| 1 = 0|

eg: 0x1A ^ 0x3C = 0x26

        0x1A = 0001 1010
    ^   0x3C = 0011 1100
    --------------------------
               0010 0110 == 0x26
    

**"~"** : 取反，则是将一个二进制的每一位按位取反即0和1互换。如 0b0010 取反即 ~0b0010 = 0b1101

eg: ~0x1A = 0xE5

    0x1A = 0001 1010 = ~ 0001 1010 = 1110 0101 
    

**">>"** : 位右移，将一个二进制值整体右移

    1 >> 2 
    
    0001 >> 2 ==>  | 4位空间大小|
                   | 0  0 0 1 |
                   | 0  0 0 0 |01 //01 被移出存放空间
    
eg: 0x1C >> 2 == 0x0F

    0x1C = 0001 1100|
           0000 0111|00
    

**"<<"** : 位左移，将一个二进制值整体左移

    1 << 2
    0001 << 2 ====>    |0010
                     00|1000  == 8
                     
eg: 0x1C << 2 == 0xE0 

    0x1C =     |0001 1100
             00|0111 0000
             
             
### 例子公式
将一个二进制数X的第n位设为1 。
则公式: **<font color="red">X |= (0x1 << n)</font>**,因为是单独1进行位移，所以这里可以是0x01<<n,0x1<<n,0b1<<n,1<<n都可以

    如将0x81的第4位的值重置为1，即X = 0x81 = 1000 0001  ==> 1000 1001 = 0x89
    过程：
       1、0x1 << 4 === 0001 << 4 = 1000
       2、将1000 0001 和 0000 1000 进行或运算。
       1000 0001
    |  0000 1000    
    --------------
       1000 1001
    
将一个二进制数的第n位设为0 。
则公式: **<font color ="red">X &= ~(0x1 << n)</font>**  
    
    如将0xFE 的第6位重置为0，即X = 0xFE = 1111 0111 = 1101 0111 = 0xDE
    过程：
        1、0x1 << 6 === 0001 << 6 = 10 0000
        2、将10 0000 取反即(~0010 0000 = 1101 1111)
        3、将原来的值和01 1111进行与运算
        
           1111 0111
        &  1101 1111
        -------------
           1101 0111  = 0xDE
           
        


## 锁存器

原理图：
![img](/assets/articles/ic/basic/lock.jpg)

    锁存1 ，如图一:
    t0时刻：当A输入0时，输出0，同时把0反馈回B输入端。
    t1时刻：当A输入1时，此时输出为1，同时把1反馈给B。
    当T > t1时刻，不管A输入的是0，还是1，最终输出都是 1， 因为或操作只要有一个是1，则输出为1 

    锁存0，如图二:
    t0时刻：当A输入1时，B输入1时，输出为1，同时把1反馈给B。
    t1时刻：当A输入0时，此时输出为0，同时把0反馈给B。
    当T > t1时刻，不管A输入0还是1，输出都为0，因为与操作，只有同时为1时才为1
    
    根据输入条件进行锁0还是锁1，如图三：
    t0时刻：当设置B=1 时，此时就进行锁0操作。不管A输入什么，输出都只能是0
    t1时刻：当设置B=0，且A输入1时，则锁存为1
    T>t1时：只要保持B=0，则A输入不管是什么都只能输出1
    

与、非、或、与非、或非门电路：
![img](/assets/articles/ic/basic/logic.svg)


锁存器电路图：

![img](/assets/articles/ic/basic/logic_or.jpg)

![img](/assets/articles/ic/basic/logic_or_1.jpg)

![img](/assets/articles/ic/basic/lock_register.svg)

1、**初始态：B=0，RET=0，亮灭：**

初始状态，A，B，RET是低电平，此时Q18，Q19，Q31导通，因此Q19的集电极为高电平，从而使得Q26导通，把OUT（即C点）的电平拉低到地，Q31导通后D点输出高电平。此时C点为低电平，D为高电平，使用Q22，Q29导通，由于Q22导通后，使用Q28的基极为高电平，把OUT导通到地此时输出低电平，同时也把输出反馈到A点。此时LED不亮。

2、**B= 1， RET= 0， A= 0， 灯亮**

B为高电平，RET为低电平时，此时A仍为低电平，Q18导通，Q19截止，Q25导通把Q20的基极通过Q25导通成为代电平，从而把Q20导通，使得C点的电平为高电平。由于C，D同时为高电平，Q27，Q29导通，把Q23的基极拉为低电平导至Q23导通，使得OUT输出为高电平，此时灯亮。

3、**保持RET=0，此时B由1变为0，因为步聚2时，使用A的反馈点为1**

在此状态下，由于A为1，Q24导通，把Q20的基极拉为电平，从而导通，此时C点输出为高电平，同时D点为高电平，则Q27，Q29导通，把Q23的基极拉为低电平导通，从而输出仍然是高电平。

可见，只要在第二步之后，RET只要保持低电平，则不错B点输出的是0，还是1，输出依然是1

4、**保持步聚2运行的情况下，此时把RET设为1,即此时的最终状态是由B=1，RET=0，A=1， 变为B1=1,RET=1,A=1**

由于B=1，A=1，Q24，Q25导通，使用Q20导通，C点为1，RET=1时，Q30导通D点为0，此时Q21导通，使得Q28的基极为高电平，导通，直接把OUT拉低到地变为0，同时反馈给A。灯灭。



![img](/assets/articles/ic/basic/register.jpg)
