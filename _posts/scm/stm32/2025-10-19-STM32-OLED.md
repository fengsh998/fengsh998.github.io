---
layout: post
title: "STM32(自学)-点亮OLED屏【ssd1306驱动芯片128x64】(六)"
categories: STM32
tags: STM32
author: fengsh998
typora-root-url: ..
---


网上搞了一块OLED屏回来，商家给到的资料都是标准库的OLED封装，在CubeIDE上，现在都大多基于HAL库了，没有经验的话，一时半会还改不上来。折腾了半天也点不亮，一度怀疑屏有问题。正好手上有一块Arduino Uno R3 的开发版，这个有较好的封装库，先用这个来验一下屏是否正常，后结搞懂STM32的相关编程后再来点亮。


硬件接线：

|OLED(7Pin4线SPI)|Arduino 引脚| STM32F103C8T6 开发板|
|---|-----|-----|
|GND|GND|GND|
|VCC|3V3|3V3|
|SCK/D0 时钟|D13|PA5|
|SDA/MOSI/D1/DIN 数据|D11|PA7|
|RST 复位|D8|PB0|
|DC 数据/命令切换|D9|PB1|
|CS/NSS 片选|D10|PA4|

OLED 不需要 MISO（因为它只接收，不发送），所以用 D/C 线来切换「命令」还是「数据」

通信协议
|总线|信号线数量|线名|
|----|----|---|
|SPI（四线）|4|SCK, MOSI, CS, DC|
|$$ I^2C $$|2|SCL, SDA|

## Arduino Uno R3

实物接线图：

![img](/assets/articles/ic/stm32/oled/oled1.jpg)
![img](/assets/articles/ic/stm32/oled/oled2.jpg)

使用Arduino 时，需要安装U8g2库,打开库管理-> U8g2 安装

![img](/assets/articles/ic/stm32/oled/ardunio1.jpg)

程序：
```c
#include <U8g2lib.h>

// 正确：构造函数名是大写 U8G2
U8G2_SSD1306_128X64_NONAME_F_4W_HW_SPI U8G2(
    U8G2_R0,      // 不旋转
    /* cs=*/ 10,   // CS  → D10
    /* dc=*/ 9,    // DC  → D9
    /* reset=*/ 8  // RST → D8
);

void setup(void) {
  U8G2.begin();                    // 初始化
  
}

void loop(void) {
  U8G2.clearBuffer();              // 清缓冲区
  U8G2.setFont(u8g2_font_ncenB14_tr); // 设置字体
  U8G2.drawStr(0, 20, "HELLO!");
  U8G2.drawStr(0, 40, "SSD1306 OK");
  U8G2.drawStr(0, 60, "7Pin SPI");
  U8G2.sendBuffer();               // 发送到屏幕
  // 保持显示
}
```
直接烧录完，Reset一把就可以显示了。接下来得捣整一下STM32的了。


## STM32F103C8T6 + Hal库(CubeIDE) 硬件SPI通信。
1、配置串口调试。

Pinout & Configuration -> System Core -> Sys 的Debug选 Serial Wire.

![img](/assets/articles/ic/stm32/oled/oled_1_spi1.jpg)

2、配置时钟。

Pinout & Configuration -> System Core -> RCC -> HSE 选 Crystal/Ceramic Resonator,并到Clock Configuration 下配置选HSE，修改HCLK(MHz) 为72

![img](/assets/articles/ic/stm32/oled/oled_1_spi2.jpg)
![img](/assets/articles/ic/stm32/oled/oled_1_spi3.jpg)

3、配置SPI。

![img](/assets/articles/ic/stm32/oled/oled_1_spi4.jpg)
![img](/assets/articles/ic/stm32/oled/oled_1_spi5.jpg)

4、配置DC,CS,RES的GPIO。

GPIO设置初始为高电平，推挽输出，上拉电阻，传输率这个我试了下选LOW和HIGH都能正常显示。

![img](/assets/articles/ic/stm32/oled/oled_1_spi6.jpg)
![img](/assets/articles/ic/stm32/oled/oled_1_spi7.jpg)

5、通过配置生成基本的代码。

![img](/assets/articles/ic/stm32/oled/oled_1_spi8.jpg)

### 自动生成的代码
main.c中生成的**<font color="red">系统时钟配置代码</font>**：

```c
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}
```
由于使用的是cubeIdeMx配置配置的SPI，所以会产生一个spi.h/spi.c的文件，生成必须的SPI通信配置。**<font color="red">SPI配置代码</font>**

```c
// 全局引用hspi句柄
SPI_HandleTypeDef hspi1;

/* SPI1 init function */
void MX_SPI1_Init(void)
{

  /* USER CODE BEGIN SPI1_Init 0 */

  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
```

**<font color="red">自动生成GPIO代码</font>**

```c
void MX_GPIO_Init(void)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable 使能*/
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level 配置LED高电平*/
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level 默认DC，CS，RES为高电平*/
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4, GPIO_PIN_SET);

  /*Configure GPIO pin : PC13 */
  GPIO_InitStruct.Pin = GPIO_PIN_13;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : PA2 PA3 PA4 */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

}
```

硬件连接图：

下面使用的是芯片自带的PA5(SCK)，PA7(MOSI)的SPI协议脚，由于只需要往屏传输数据，不需要接收数据，所以选Master模式即可。

|STM32F103C8T6开发版(SPI1)|OLED屏(7脚)|
|---|---|
|3V3|VCC|
|GND|GND|
|PA5|SCK/D0|
|PA7|SDA/D1|
|PA4|CS|
|PA3|DC|
|PA2|RES|

![img](/assets/articles/ic/stm32/oled/oled_1_spi9.jpg)

开始编码点亮OLED屏

font5x7.h

```c
#ifndef INC_FONT5X7_H_
#define INC_FONT5X7_H_

#include <stdint.h>

/* 5x7 font for ASCII 32..126.
   Each character is 5 bytes (columns), LSB is the top pixel.
   Source: classic 5x7 font used commonly in embedded examples.
*/
static const uint8_t Font5x7[] = {
  /* 32 ' ' */ 0x00,0x00,0x00,0x00,0x00,
  /* 33 '!' */ 0x00,0x00,0x5F,0x00,0x00,
  /* 34 '"' */ 0x00,0x07,0x00,0x07,0x00,
  /* 35 '#' */ 0x14,0x7F,0x14,0x7F,0x14,
  /* 36 '$' */ 0x24,0x2A,0x7F,0x2A,0x12,
  /* 37 '%' */ 0x23,0x13,0x08,0x64,0x62,
  /* 38 '&' */ 0x36,0x49,0x55,0x22,0x50,
  /* 39 ''' */ 0x00,0x05,0x03,0x00,0x00,
  /* 40 '(' */ 0x00,0x1C,0x22,0x41,0x00,
  /* 41 ')' */ 0x00,0x41,0x22,0x1C,0x00,
  /* 42 '*' */ 0x14,0x08,0x3E,0x08,0x14,
  /* 43 '+' */ 0x08,0x08,0x3E,0x08,0x08,
  /* 44 ',' */ 0x00,0x50,0x30,0x00,0x00,
  /* 45 '-' */ 0x08,0x08,0x08,0x08,0x08,
  /* 46 '.' */ 0x00,0x60,0x60,0x00,0x00,
  /* 47 '/' */ 0x20,0x10,0x08,0x04,0x02,
  /* 48 '0' */ 0x3E,0x51,0x49,0x45,0x3E,
  /* 49 '1' */ 0x00,0x42,0x7F,0x40,0x00,
  /* 50 '2' */ 0x42,0x61,0x51,0x49,0x46,
  /* 51 '3' */ 0x21,0x41,0x45,0x4B,0x31,
  /* 52 '4' */ 0x18,0x14,0x12,0x7F,0x10,
  /* 53 '5' */ 0x27,0x45,0x45,0x45,0x39,
  /* 54 '6' */ 0x3C,0x4A,0x49,0x49,0x30,
  /* 55 '7' */ 0x01,0x71,0x09,0x05,0x03,
  /* 56 '8' */ 0x36,0x49,0x49,0x49,0x36,
  /* 57 '9' */ 0x06,0x49,0x49,0x29,0x1E,
  /* 58 ':' */ 0x00,0x36,0x36,0x00,0x00,
  /* 59 ';' */ 0x00,0x56,0x36,0x00,0x00,
  /* 60 '<' */ 0x08,0x14,0x22,0x41,0x00,
  /* 61 '=' */ 0x14,0x14,0x14,0x14,0x14,
  /* 62 '>' */ 0x00,0x41,0x22,0x14,0x08,
  /* 63 '?' */ 0x02,0x01,0x51,0x09,0x06,
  /* 64 '@' */ 0x32,0x49,0x79,0x41,0x3E,
  /* 65 'A' */ 0x7E,0x11,0x11,0x11,0x7E,
  /* 66 'B' */ 0x7F,0x49,0x49,0x49,0x36,
  /* 67 'C' */ 0x3E,0x41,0x41,0x41,0x22,
  /* 68 'D' */ 0x7F,0x41,0x41,0x22,0x1C,
  /* 69 'E' */ 0x7F,0x49,0x49,0x49,0x41,
  /* 70 'F' */ 0x7F,0x09,0x09,0x09,0x01,
  /* 71 'G' */ 0x3E,0x41,0x49,0x49,0x7A,
  /* 72 'H' */ 0x7F,0x08,0x08,0x08,0x7F,
  /* 73 'I' */ 0x00,0x41,0x7F,0x41,0x00,
  /* 74 'J' */ 0x20,0x40,0x41,0x3F,0x01,
  /* 75 'K' */ 0x7F,0x08,0x14,0x22,0x41,
  /* 76 'L' */ 0x7F,0x40,0x40,0x40,0x40,
  /* 77 'M' */ 0x7F,0x02,0x04,0x02,0x7F,
  /* 78 'N' */ 0x7F,0x04,0x08,0x10,0x7F,
  /* 79 'O' */ 0x3E,0x41,0x41,0x41,0x3E,
  /* 80 'P' */ 0x7F,0x09,0x09,0x09,0x06,
  /* 81 'Q' */ 0x3E,0x41,0x51,0x21,0x5E,
  /* 82 'R' */ 0x7F,0x09,0x19,0x29,0x46,
  /* 83 'S' */ 0x46,0x49,0x49,0x49,0x31,
  /* 84 'T' */ 0x01,0x01,0x7F,0x01,0x01,
  /* 85 'U' */ 0x3F,0x40,0x40,0x40,0x3F,
  /* 86 'V' */ 0x1F,0x20,0x40,0x20,0x1F,
  /* 87 'W' */ 0x3F,0x40,0x38,0x40,0x3F,
  /* 88 'X' */ 0x63,0x14,0x08,0x14,0x63,
  /* 89 'Y' */ 0x07,0x08,0x70,0x08,0x07,
  /* 90 'Z' */ 0x61,0x51,0x49,0x45,0x43,
  /* 91 '[' */ 0x00,0x7F,0x41,0x41,0x00,
  /* 92 '\' */0x02,0x04,0x08,0x10,0x20,
  /* 93 ']' */ 0x00,0x41,0x41,0x7F,0x00,
  /* 94 '^' */ 0x04,0x02,0x01,0x02,0x04,
  /* 95 '_' */ 0x40,0x40,0x40,0x40,0x40,
  /* 96 '`' */ 0x00,0x01,0x02,0x04,0x00,
  /* 97 'a' */ 0x20,0x54,0x54,0x54,0x78,
  /* 98 'b' */ 0x7F,0x48,0x44,0x44,0x38,
  /* 99 'c' */ 0x38,0x44,0x44,0x44,0x20,
  /*100 'd' */ 0x38,0x44,0x44,0x48,0x7F,
  /*101 'e' */ 0x38,0x54,0x54,0x54,0x18,
  /*102 'f' */ 0x08,0x7E,0x09,0x01,0x02,
  /*103 'g' */ 0x0C,0x52,0x52,0x52,0x3E,
  /*104 'h' */ 0x7F,0x08,0x04,0x04,0x78,
  /*105 'i' */ 0x00,0x44,0x7D,0x40,0x00,
  /*106 'j' */ 0x20,0x40,0x44,0x3D,0x00,
  /*107 'k' */ 0x7F,0x10,0x28,0x44,0x00,
  /*108 'l' */ 0x00,0x41,0x7F,0x40,0x00,
  /*109 'm' */ 0x7C,0x04,0x18,0x04,0x78,
  /*110 'n' */ 0x7C,0x08,0x04,0x04,0x78,
  /*111 'o' */ 0x38,0x44,0x44,0x44,0x38,
  /*112 'p' */ 0x7C,0x14,0x14,0x14,0x08,
  /*113 'q' */ 0x08,0x14,0x14,0x18,0x7C,
  /*114 'r' */ 0x7C,0x08,0x04,0x04,0x08,
  /*115 's' */ 0x48,0x54,0x54,0x54,0x20,
  /*116 't' */ 0x04,0x3F,0x44,0x40,0x20,
  /*117 'u' */ 0x3C,0x40,0x40,0x20,0x7C,
  /*118 'v' */ 0x1C,0x20,0x40,0x20,0x1C,
  /*119 'w' */ 0x3C,0x40,0x30,0x40,0x3C,
  /*120 'x' */ 0x44,0x28,0x10,0x28,0x44,
  /*121 'y' */ 0x0C,0x50,0x50,0x50,0x3C,
  /*122 'z' */ 0x44,0x64,0x54,0x4C,0x44,
  /*123 '{' */ 0x00,0x08,0x36,0x41,0x00,
  /*124 '|' */ 0x00,0x00,0x7F,0x00,0x00,
  /*125 '}' */ 0x00,0x41,0x36,0x08,0x00,
  /*126 '~' */ 0x08,0x04,0x08,0x10,0x08
};

#endif /* INC_FONT5X7_H_ */
```


ssd1306.h
```c
#ifndef INC_SSD1306_H_
#define INC_SSD1306_H_

#include "stm32f1xx_hal.h"
#include <stdint.h>
#include <stddef.h>

#define SSD1306_WIDTH  128
#define SSD1306_HEIGHT 64
#define SSD1306_BUFFER_SIZE (SSD1306_WIDTH * SSD1306_HEIGHT / 8)

/* 导出 SPI 句柄（在 main.c 中定义并初始化） */
extern SPI_HandleTypeDef hspi1;

/* SSD1306 硬件管脚，按需修改 */
#define SSD1306_CS_GPIO_Port    GPIOA
#define SSD1306_CS_Pin          GPIO_PIN_4

#define SSD1306_DC_GPIO_Port    GPIOA
#define SSD1306_DC_Pin          GPIO_PIN_3

#define SSD1306_RST_GPIO_Port   GPIOA
#define SSD1306_RST_Pin         GPIO_PIN_2

/* API */
void ssd1306_reset(void);
void ssd1306_write_command(uint8_t cmd);
void ssd1306_write_data(uint8_t* buff, size_t len);
void ssd1306_init(void);
void ssd1306_fill_screen(uint8_t pattern); /* pattern = 0x00 或 0xFF */
void ssd1306_display_full(uint8_t* buff, size_t len);

/* 帧缓冲与基本绘图/文字接口 */
void ssd1306_Clear(void);                             /* 清帧缓冲（不立即刷新） */
void ssd1306_UpdateScreen(void);                      /* 将帧缓冲一次性写入屏幕 */
void ssd1306_DrawPixel(int16_t x, int16_t y, uint8_t color); /* 在帧缓冲上设置像素 */
void ssd1306_Putc(char ch, uint8_t x, uint8_t y);     /* 在帧缓冲上写单个字符（不刷新） */
void ssd1306_Puts(const char* str, uint8_t x, uint8_t y); /* 写字符串（不刷新） */
void ssd1306_PutInteger(int32_t num, uint8_t x, uint8_t y); /* 写整数（不刷新） */


#endif /* INC_SSD1306_H_ */
```

ssd1306.c

```c
#include "ssd1306.h"
#include "stm32f1xx_hal.h"
#include "font5x7.h"
#include <string.h> /* memset */
#include <stdlib.h> /* NULL */
#include <stdint.h>

/* 注意：hspi1 在 main.c 中定义并初始化 */
extern SPI_HandleTypeDef hspi1;

/* 短函数封装 */
static inline void SSD1306_CS_LOW(void)  { HAL_GPIO_WritePin(SSD1306_CS_GPIO_Port, SSD1306_CS_Pin, GPIO_PIN_RESET); }
static inline void SSD1306_CS_HIGH(void) { HAL_GPIO_WritePin(SSD1306_CS_GPIO_Port, SSD1306_CS_Pin, GPIO_PIN_SET);  }
static inline void SSD1306_DC_LOW(void)  { HAL_GPIO_WritePin(SSD1306_DC_GPIO_Port, SSD1306_DC_Pin, GPIO_PIN_RESET); }
static inline void SSD1306_DC_HIGH(void) { HAL_GPIO_WritePin(SSD1306_DC_GPIO_Port, SSD1306_DC_Pin, GPIO_PIN_SET);  }
static inline void SSD1306_RST_LOW(void) { HAL_GPIO_WritePin(SSD1306_RST_GPIO_Port, SSD1306_RST_Pin, GPIO_PIN_RESET); }
static inline void SSD1306_RST_HIGH(void){ HAL_GPIO_WritePin(SSD1306_RST_GPIO_Port, SSD1306_RST_Pin, GPIO_PIN_SET);  }

/* 局部帧缓冲 */
static uint8_t SSD1306_Buffer[SSD1306_BUFFER_SIZE];

/* 硬复位 */
void ssd1306_reset(void)
{
    SSD1306_RST_LOW();
    HAL_Delay(10);
    SSD1306_RST_HIGH();
    HAL_Delay(10);
}

/* 通过 SPI 发命令（DC=0） */
void ssd1306_write_command(uint8_t cmd)
{
    SSD1306_DC_LOW();
    SSD1306_CS_LOW();
    HAL_SPI_Transmit(&hspi1, &cmd, 1, HAL_MAX_DELAY);
    SSD1306_CS_HIGH();
}

/* 通过 SPI 发数据（DC=1） */
void ssd1306_write_data(uint8_t* buff, size_t len)
{
    SSD1306_DC_HIGH();
    SSD1306_CS_LOW();
    HAL_SPI_Transmit(&hspi1, buff, len, HAL_MAX_DELAY);
    SSD1306_CS_HIGH();
}

/* 初始化 SSD1306 (128x64) 的常用序列 */
void ssd1306_init(void)
{
    ssd1306_reset();

    /* Initialization sequence for 128x64 */
    ssd1306_write_command(0xAE); // Display off
    ssd1306_write_command(0x20); // Set Memory Addressing Mode
    ssd1306_write_command(0x00); // Horizontal addressing mode
    ssd1306_write_command(0xB0); // Set Page Start Address for Page Addressing Mode, 0-7
    ssd1306_write_command(0xC8); // COM Output Scan Direction remapped
    ssd1306_write_command(0x00); // --set low column address
    ssd1306_write_command(0x10); // --set high column address
    ssd1306_write_command(0x40); // --set start line address
    ssd1306_write_command(0x81); // Set contrast control
    ssd1306_write_command(0x7F);
    ssd1306_write_command(0xA1); // Segment remap
    ssd1306_write_command(0xA6); // Normal display (A7 for inverse)
    ssd1306_write_command(0xA8); // Multiplex ratio
    ssd1306_write_command(0x3F); // 1/64 duty
    ssd1306_write_command(0xA4); // Output ram to display (0xA4 resume, 0xA5 ignore)
    ssd1306_write_command(0xD3); // Display offset
    ssd1306_write_command(0x00); // no offset
    ssd1306_write_command(0xD5); // Display clock divide ratio/oscillator freq
    ssd1306_write_command(0x80);
    ssd1306_write_command(0xD9); // Pre-charge period
    ssd1306_write_command(0xF1);
    ssd1306_write_command(0xDA); // COM pins hardware config
    ssd1306_write_command(0x12);
    ssd1306_write_command(0xDB); // VCOMH deselect level
    ssd1306_write_command(0x40);
    ssd1306_write_command(0x8D); // Charge pump
    ssd1306_write_command(0x14); // enable
    ssd1306_write_command(0xAF); // Display ON
    HAL_Delay(10);

    /* 初始化本地帧缓冲为全清 */
    ssd1306_Clear();
    ssd1306_UpdateScreen();
}

/* 将整个显存写入（设置列地址和页地址后发 1024 字节） */
void ssd1306_display_full(uint8_t* buff, size_t len)
{
    if (len < SSD1306_BUFFER_SIZE) return; // 保护

    /* 设置列地址 0 - 127 */
    ssd1306_write_command(0x21);
    ssd1306_write_command(0x00);
    ssd1306_write_command(SSD1306_WIDTH - 1);

    /* 设置页地址 0 - 7 */
    ssd1306_write_command(0x22);
    ssd1306_write_command(0x00);
    ssd1306_write_command((SSD1306_HEIGHT/8) - 1);

    /* 发送数据 */
    ssd1306_write_data(buff, SSD1306_BUFFER_SIZE);
}

/* 快速填屏（用于测试），pattern = 0xFF: 全亮，0x00: 全灭，其他: 模式 */
void ssd1306_fill_screen(uint8_t pattern)
{
	for (int i = 0; i < SSD1306_BUFFER_SIZE; i++) SSD1306_Buffer[i] = pattern;

	ssd1306_UpdateScreen();
}

/* 清帧缓冲（不刷新） */
void ssd1306_Clear(void)
{
    memset(SSD1306_Buffer, 0x00, SSD1306_BUFFER_SIZE);
}

/* 将帧缓冲一次性写入屏幕（刷新） */
void ssd1306_UpdateScreen(void)
{
    ssd1306_display_full(SSD1306_Buffer, SSD1306_BUFFER_SIZE);
}

/* 在帧缓冲上设置像素
   color: 1=点亮, 0=熄灭
   (0,0) 为屏幕左上角，x:0..127, y:0..63
*/
void ssd1306_DrawPixel(int16_t x, int16_t y, uint8_t color)
{
    if ((x < 0) || (x >= SSD1306_WIDTH) || (y < 0) || (y >= SSD1306_HEIGHT)) return;

    uint16_t index = x + (y / 8) * SSD1306_WIDTH;
    uint8_t bit = 1 << (y % 8);

    if (color)
        SSD1306_Buffer[index] |= bit;
    else
        SSD1306_Buffer[index] &= ~bit;
}

/* 写单字节字符（使用 Font5x7: 5 列 + 1 空白列，总宽 6）
   x,y 指顶点像素坐标（y 在 0..56 之间以保证 8 像素高字符能显示完整）
   注意：不自动刷新屏幕，调用者需手动 ssd1306_UpdateScreen()
*/
void ssd1306_Putc(char ch, uint8_t x, uint8_t y)
{
    if ((ch < 32) || (ch > 126)) ch = '?';
    uint16_t cindex = (ch - 32) * 5;
    for (uint8_t i = 0; i < 5; i++) {
        uint8_t line = Font5x7[cindex + i];
        for (uint8_t j = 0; j < 8; j++) {
            if (line & (1 << j)) {
                ssd1306_DrawPixel(x + i, y + j, 1);
            } else {
                ssd1306_DrawPixel(x + i, y + j, 0);
            }
        }
    }
    /* spacing column */
    for (uint8_t j = 0; j < 8; j++) {
        ssd1306_DrawPixel(x + 5, y + j, 0);
    }
}

/* 写字符串（不刷新） */
void ssd1306_Puts(const char* str, uint8_t x, uint8_t y)
{
    uint8_t cursor_x = x;
    while (*str) {
        if (cursor_x + 6 > SSD1306_WIDTH) break; /* 超出宽度则停止 */
        ssd1306_Putc(*str, cursor_x, y);
        cursor_x += 6; /* 字宽 6 */
        str++;
    }
}

/* 将整数转换为字符串并写出（不刷新） */
void ssd1306_PutInteger(int32_t num, uint8_t x, uint8_t y)
{
    char buf[12]; /* 足够存放 -2147483648\0 */
    char *p = buf + sizeof(buf) - 1;
    uint8_t negative = 0;
    *p = '\0';

    if (num == 0) {
        buf[0] = '0';
        buf[1] = '\0';
        ssd1306_Puts(buf, x, y);
        return;
    }

    if (num < 0) {
        negative = 1;
        /* 处理 -2147483648 的情况：使用 unsigned 倒序构建 */
        uint32_t un = (uint32_t)(-(num + 1)) + 1;
        uint32_t v = un;
        while (v > 0) {
            *(--p) = '0' + (v % 10);
            v /= 10;
        }
    } else {
        uint32_t v = (uint32_t)num;
        while (v > 0) {
            *(--p) = '0' + (v % 10);
            v /= 10;
        }
    }

    if (negative) {
        *(--p) = '-';
    }

    ssd1306_Puts(p, x, y);
}
```

修改main.c 进行屏显测试代码：
示例一：全屏点亮
```c
...
#include "spi.h"
#include "gpio.h"
#include "ssd1306.h"
#include <stdio.h>

....

MX_GPIO_Init();
MX_SPI1_Init();

ssd1306_init();

  /* 用 0xFF 填充整屏（全部点亮）用于测试 */
ssd1306_fill_screen(0xFF);
HAL_Delay(500);

while (1) {

}

...

```

示例二： 在屏幕顶部显示字符串与数字

```c
...
#include "spi.h"
#include "gpio.h"
#include "ssd1306.h"
#include <stdio.h>

....

MX_GPIO_Init();
MX_SPI1_Init();

ssd1306_init();

ssd1306_Clear();
ssd1306_Puts("Hello, STM32!", 0, 0);     /* 在 (0,0) 写字符串（不刷新） */
ssd1306_Puts("SSD1306 Demo", 0, 8);     /* 在 (0,8) 再写一行 */
ssd1306_PutInteger(2025, 0, 16);        /* 在 (0,16) 写整数 */
ssd1306_UpdateScreen();                 /* 一次性刷新到屏幕 */
HAL_Delay(1500);

int counter = 0;
while (1) { //While中更新计数
    char buf[16];
	/* 更新屏幕某行数值（先在缓冲该区域清除） */
	ssd1306_Clear();
	ssd1306_Puts("Counter:", 0, 0);
	/* 整数转换为字符串再显示（也可以直接用 PutInteger） */
	snprintf(buf, sizeof(buf), "%d", counter++);
	ssd1306_Puts(buf, 0, 8);
	ssd1306_UpdateScreen();

	HAL_Delay(1000);
	if (counter > 9999) counter = 0;
}
```

### 使用STM32F103C8T6的SPI2组进行

![img](/assets/articles/ic/stm32/oled/oled_1_spi2_1.jpg)

重新修改硬件接线：

|STM32F103C8T6开发版(SPI2)|OLED屏(7脚)|
|---|---|
|3V3|VCC|
|GND|GND|
|PB13|SCK/D0|
|PB15|SDA/D1|
|PB10|CS|
|PB1|DC|
|PB0|RES|

![img](/assets/articles/ic/stm32/oled/oled_1_spi2_2.jpg)

只需要修改一下Pin脚的宏即可。

修改ssd1306.h
```c
...
//因为用了spi2自动生成的引用实例是hspi2，这里要同步修改.c中的使用
extern SPI_HandleTypeDef hspi2;

// 把原来的修改成PB0，PB1，PB10
#define SSD1306_CS_GPIO_Port    GPIOB
#define SSD1306_CS_Pin          GPIO_PIN_10

#define SSD1306_DC_GPIO_Port    GPIOB
#define SSD1306_DC_Pin          GPIO_PIN_1

#define SSD1306_RST_GPIO_Port   GPIOB
#define SSD1306_RST_Pin         GPIO_PIN_0
...
```

修改ssd1306.c

```c
/* 通过 SPI 发命令（DC=0） */
void ssd1306_write_command(uint8_t cmd)
{
    SSD1306_DC_LOW();
    SSD1306_CS_LOW();
    // 修改为使用hspi2
    HAL_SPI_Transmit(&hspi2, &cmd, 1, HAL_MAX_DELAY);
    SSD1306_CS_HIGH();
}

/* 通过 SPI 发数据（DC=1） */
void ssd1306_write_data(uint8_t* buff, size_t len)
{
    SSD1306_DC_HIGH();
    SSD1306_CS_LOW();
    // 修改为使用hspi2
    HAL_SPI_Transmit(&hspi2, buff, len, HAL_MAX_DELAY);
    SSD1306_CS_HIGH();
}
```
其它代码不需要修改，就可以进行烧录跑机了。

## STM32F103C8T6 软件编程的方式进行SPI通讯

时钟的配置看前面的内容，下面只需要配GPIO口使用即可。

![img](/assets/articles/ic/stm32/oled/oled_2_spi1.jpg)

硬件连接：

随便选GPIO口，只要同一个IO口不同时使用两种功能就行。下面我选的是PA0,PA1,PA2,PA3,PA4

|STM32F103C8T6开发版(SPI2)|OLED屏(7脚)|
|---|---|
|3V3|VCC|
|GND|GND|
|PA0|SCK/D0|
|PA1|SDA/D1|
|PA2|CS|
|PA3|DC|
|PA4|RES|

![img](/assets/articles/ic/stm32/oled/oled_2_spi2.jpg)

![img](/assets/articles/ic/stm32/oled/oled_2_spi3.jpg)


自动生成的时钟代码：

```c
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}
```

自动生成的GPIO代码：

```c
void MX_GPIO_Init(void)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*LED灯 */
  HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);

  /* PA0, PA1,PA2,PA3,PA4 全部初始化为高电平 */
  HAL_GPIO_WritePin(GPIOA, SPI_SCK_Pin|SPI_SDA_Pin|SPI_CS_Pin|SPI_DC_Pin
                          |SPI_RST_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin : LED_Pin */
  GPIO_InitStruct.Pin = LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);

  /* PA0, PA1,PA2,PA3,PA4 配置为推挽输出，上拉，低速 */
  GPIO_InitStruct.Pin = SPI_SCK_Pin|SPI_SDA_Pin|SPI_CS_Pin|SPI_DC_Pin
                          |SPI_RST_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

}
```

SPI通信封装：

oled_sw.h

```c
#ifndef INC_OLED_SW_H_
#define INC_OLED_SW_H_

#include "stm32f1xx_hal.h"
#include <stdint.h>
#include <stddef.h>

/* 128x64 SSD1306 */
#define SSD1306_WIDTH  128
#define SSD1306_HEIGHT 64
#define SSD1306_BUFFER_SIZE (SSD1306_WIDTH * SSD1306_HEIGHT / 8)

/* 软件 SPI 引脚定义（全用 GPIO 模拟，避免使用硬件 SPI 外设管脚配置）
   默认示例使用 PA0..PA4，必要时按你的板子修改这些定义 */
#define SSD1306_SCK_GPIO_Port   GPIOA
#define SSD1306_SCK_Pin         GPIO_PIN_0

#define SSD1306_MOSI_GPIO_Port  GPIOA
#define SSD1306_MOSI_Pin        GPIO_PIN_1

#define SSD1306_CS_GPIO_Port    GPIOA
#define SSD1306_CS_Pin          GPIO_PIN_2

#define SSD1306_DC_GPIO_Port    GPIOA
#define SSD1306_DC_Pin          GPIO_PIN_3

#define SSD1306_RST_GPIO_Port   GPIOA
#define SSD1306_RST_Pin         GPIO_PIN_4

/* API */
void ssd1306_init(void);
void ssd1306_reset(void);
void ssd1306_fill_screen(uint8_t pattern); /* 0xFF 全亮，0x00 全暗 */
void ssd1306_display_full(uint8_t* buff, size_t len);

/* 帧缓冲简单接口（用于以后扩展） */
void ssd1306_Clear(void);
void ssd1306_UpdateScreen(void);

#endif /* INC_OLED_SW_H_ */
```

oled_sw.c

```c
#include "oled_sw.h"
#include "stm32f1xx_hal.h"
#include <string.h>

/* 局部帧缓冲 */
static uint8_t SSD1306_Buffer[SSD1306_BUFFER_SIZE];

/* 短函数封装 */
static inline void SCK_HIGH(void)  { HAL_GPIO_WritePin(SSD1306_SCK_GPIO_Port, SSD1306_SCK_Pin, GPIO_PIN_SET); }
static inline void SCK_LOW(void)   { HAL_GPIO_WritePin(SSD1306_SCK_GPIO_Port, SSD1306_SCK_Pin, GPIO_PIN_RESET); }
static inline void MOSI_HIGH(void) { HAL_GPIO_WritePin(SSD1306_MOSI_GPIO_Port, SSD1306_MOSI_Pin, GPIO_PIN_SET); }
static inline void MOSI_LOW(void)  { HAL_GPIO_WritePin(SSD1306_MOSI_GPIO_Port, SSD1306_MOSI_Pin, GPIO_PIN_RESET); }
static inline void CS_HIGH(void)   { HAL_GPIO_WritePin(SSD1306_CS_GPIO_Port, SSD1306_CS_Pin, GPIO_PIN_SET); }
static inline void CS_LOW(void)    { HAL_GPIO_WritePin(SSD1306_CS_GPIO_Port, SSD1306_CS_Pin, GPIO_PIN_RESET); }
static inline void DC_HIGH(void)   { HAL_GPIO_WritePin(SSD1306_DC_GPIO_Port, SSD1306_DC_Pin, GPIO_PIN_SET); }
static inline void DC_LOW(void)    { HAL_GPIO_WritePin(SSD1306_DC_GPIO_Port, SSD1306_DC_Pin, GPIO_PIN_RESET); }
static inline void RST_HIGH(void)  { HAL_GPIO_WritePin(SSD1306_RST_GPIO_Port, SSD1306_RST_Pin, GPIO_PIN_SET); }
static inline void RST_LOW(void)   { HAL_GPIO_WritePin(SSD1306_RST_GPIO_Port, SSD1306_RST_Pin, GPIO_PIN_RESET); }

/* 简单短延时，用于 bit-bang 时序（需要根据编译优化和系统频率微调）
   这里以一个小循环产生近似的微延时，足够低速 SPI 通信 */
static inline void ssd1306_delay_short(void)
{
    /* 约几百 ns ~ 几 us，取决于编译器与系统频率。
       若通信不稳定，请适当加大循环次数。 */
    for (volatile uint8_t i = 0; i < 20; i++) {
        __NOP();
    }
}

/* 通过软件 SPI 发送一字节，MSB first，SPI Mode 0：空闲 SCK=0，在上升沿采样 */
static void ssd1306_sw_spi_send_byte(uint8_t data)
{
    for (uint8_t i = 0; i < 8; i++) {
        /* 输出最高位到 MOSI */
        if (data & 0x80) MOSI_HIGH();
        else MOSI_LOW();

        /* 确保数据稳定后，拉高 SCK -> 接收端在上升沿采样 */
        ssd1306_delay_short();
        SCK_HIGH();
        ssd1306_delay_short();
        /* 拉低 SCK，准备下一位 */
        SCK_LOW();
        data <<= 1;
    }
}

/* 发送命令（DC = 0） */
void ssd1306_write_command(uint8_t cmd)
{
    DC_LOW();
    CS_LOW();
    ssd1306_sw_spi_send_byte(cmd);
    CS_HIGH();
}

/* 发送一段数据（DC = 1） */
void ssd1306_write_data(uint8_t *data, size_t len)
{
    DC_HIGH();
    CS_LOW();
    for (size_t i = 0; i < len; i++) {
        ssd1306_sw_spi_send_byte(data[i]);
    }
    CS_HIGH();
}

/* 硬复位 */
void ssd1306_reset(void)
{
    RST_LOW();
    HAL_Delay(10);
    RST_HIGH();
    HAL_Delay(10);
}

/* 初始化 SSD1306（推荐按顺序） */
void ssd1306_init(void)
{
    /* 先复位 */
    ssd1306_reset();

    //初始化顺序：我按常见 SSD1306 初始化序列写入，Display OFF -> 配置 -> Charge pump -> Display ON，推荐不要随意乱序。
    /* 初始化命令序列（针对 128x64 SSD1306） */
    ssd1306_write_command(0xAE); // Display off
    ssd1306_write_command(0xD5); // Set display clock divide ratio/oscillator freq
    ssd1306_write_command(0x80);
    ssd1306_write_command(0xA8); // Set multiplex ratio(1 to 64)
    ssd1306_write_command(0x3F);
    ssd1306_write_command(0xD3); // Set display offset
    ssd1306_write_command(0x00);
    ssd1306_write_command(0x40); // Set start line address
    ssd1306_write_command(0x8D); // Charge Pump
    ssd1306_write_command(0x14); // Enable charge pump
    ssd1306_write_command(0x20); // Memory addressing mode
    ssd1306_write_command(0x00); // Horizontal addressing mode
    ssd1306_write_command(0xA1); // Segment remap
    ssd1306_write_command(0xC8); // COM scan direction remapped
    ssd1306_write_command(0xDA); // COM pins hardware config
    ssd1306_write_command(0x12);
    ssd1306_write_command(0x81); // Contrast
    ssd1306_write_command(0x7F);
    ssd1306_write_command(0xD9); // Pre-charge
    ssd1306_write_command(0xF1);
    ssd1306_write_command(0xDB); // VCOMH deselect level
    ssd1306_write_command(0x40);
    ssd1306_write_command(0xA4); // Resume to RAM content display
    ssd1306_write_command(0xA6); // Normal display
    ssd1306_write_command(0xAF); // Display ON

    /* 清空本地帧缓冲并刷新（首次亮屏） */
    memset(SSD1306_Buffer, 0x00, SSD1306_BUFFER_SIZE);
    ssd1306_UpdateScreen();
}

/* 设置 column/page 地址并发送一整块显存（1024 字节） */
void ssd1306_display_full(uint8_t* buff, size_t len)
{
    if (len < SSD1306_BUFFER_SIZE) return;

    /* horizontal addressing 下使用 column/page address 命令 */
    ssd1306_write_command(0x21); /* set column address */
    ssd1306_write_command(0x00);
    ssd1306_write_command(SSD1306_WIDTH - 1);

    ssd1306_write_command(0x22); /* set page address */
    ssd1306_write_command(0x00);
    ssd1306_write_command((SSD1306_HEIGHT / 8) - 1);

    /* 发送全部数据（会自动设置 DC=1） */
    ssd1306_write_data(buff, SSD1306_BUFFER_SIZE);
}

/* 简单填屏（修改帧缓冲并刷新） */
void ssd1306_fill_screen(uint8_t pattern)
{
    for (size_t i = 0; i < SSD1306_BUFFER_SIZE; i++) SSD1306_Buffer[i] = pattern;
    ssd1306_UpdateScreen();
}

/* 帧缓冲接口实现（用于未来扩展） */
void ssd1306_Clear(void)
{
    memset(SSD1306_Buffer, 0x00, SSD1306_BUFFER_SIZE);
}
void ssd1306_UpdateScreen(void)
{
    ssd1306_display_full(SSD1306_Buffer, SSD1306_BUFFER_SIZE);
}
```

main.c

```c
#include "main.h"
#include "gpio.h"
#include "oled_sw.h"

...
  MX_GPIO_Init();

  ssd1306_init();

  /* 让屏幕全亮（0xFF）以便确认连接与显示 */
  ssd1306_fill_screen(0xFF);
  HAL_Delay(800);
  
  while (1)
  {
	  HAL_Delay(1000);
	  HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET);
	  HAL_Delay(100);
	  HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);
  }
  ...
```

烧录即可点亮，显示白屏。



## 总结

什么是硬件SPI接口？即芯片本身出厂时默认的IO口赋予的能力，如果SPI，I2C，USART等。
软件SPI又是什么？就是随便选择IO口，通过编译代码操控SCK，SDA来实现传输协议的过程。

速度：软件 SPI 比硬件 SPI 慢，适合调试与简单显示（如亮屏、显示文字）。若后续需要快速刷新或复杂图形显示，建议改回硬件 SPI。

