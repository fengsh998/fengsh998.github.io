---
layout: post
title: "STM32(自学)-Boot启动模式(三)"
categories: STM32
tags: STM32
author: fengsh998
typora-root-url: ..
---


## 名词

**FLASH(Flash Memory)**: 非易失性存储器(断电不丢失)，芯片内部，独立硅片区域，可比喻成硬盘。
**SRAM(Static Random Access Memory)**: 易失性存储器（断电全丢）,芯片内部，高速逻辑单元,缓存可比喻成“内存条”。

**DFU(Device Firmware Upgrade)**:USB-IF 组织定义的 USB Class 协议,让设备（STM32）进入“刷机模式”，通过 USB 线接收新程序,不需要串口、J-Link、ST-Link,只需要一根 USB 线 + 电脑软件。可以理解为DFU 是一种“通过 USB 直接给芯片刷程序”的标准协议，就像用 U 盘给手机刷机一样。

## FLASH 和 SRAM作用
**STM32F103C8T6** 具体容量：

FLASH 64KB 地址范围(0x0800 0000 ~ 0x0800 FFFF) 存放 用户程序、常量。

SRAM 20KB 地址范围(0x2000 0000 ~ 0x2000 4FFF) 存放 变量、堆栈、运行数据。

**FLASH 的作用（5 大功能）**

|功能|说明|举例|
|---|---|---|
|存储用户程序|编译后的 .hex/.bin 烧录进去|main() 代码、启动文件|
|存储常量数据|用 const 修饰，放在 Flash|const uint8_t logo[] = {…}|
|支持 IAP（在线升级）|双区切换，运行一个区，升级另一个|固件升级|
|读保护（RDP）|防止程序被读出|量产防盗版|
|选项字节（Option Bytes）|配置启动、看门狗、读保护|0x1FFFF800 区域|

> FLASH 是“程序的家”，断电后程序还在，下次上电从 0x08000000 启动。
{: .prompt-tips }

**SRAM 的作用（4 大功能）**

|功能|说明|举例|
|运行时变量|int a; float b; 自动放 SRAM|局部变量、全局变量|
|堆栈（Stack）|函数调用、局部变量、中断保存现场|push {r0-r3, lr}|
|堆（Heap）|malloc() 动态分配|uint8_t *buf = malloc(1024)|
|临时高速缓冲|DMA、图像处理、中断缓冲|双缓冲乒乓|

> SRAM 是“程序的工位”，运行时才用，关机就清空。
{: .prompt-tips }

内存布局图：(STM32F103C8T6)

        0xFFFF FFFF  ┌──────────────────┐
                     │   外设寄存器      │
        0x4000 0000  ├──────────────────┤
                     │                  │
        0x2000 5000  ┌──────────────────┐
                     │     SRAM         │  ← 20KB
        0x2000 0000  ├──────────────────┤
                     │                  │
        0x1FFF F800  ┌──────────────────┐  ← 选项字节
        0x1FFF F000  ├──────────────────┤  ← 系统 Bootloader
        0x0801 0000  ┌──────────────────┐
                     │                  │
        0x0800 0000  ├──────────────────┤  ← 用户 FLASH 64KB
        0x0000 0000  └──────────────────┘


## 芯片为什么能跑代码？

STM32（包括 F103C8T6）出厂时就自带了一个“最小系统”，它能让芯片独立运行你写的代码，不需要外接电脑、操作系统或任何“主机”。

出厂就有一个“裸机启动系统“

|内部组件|出厂自带？|作用|
|---|---|---|
|CPU（Cortex-M3 内核）|是|执行你写的 add, mov, bl main 等指令|
|FLASH（64KB）|是|存放你的程序（烧进去后断电不丢）|
|SRAM（20KB）|是|程序运行时的变量、堆栈|
|时钟系统（HSI 8MHz）|是|提供 CPU 运行的“心跳”|
|复位电路|是|上电自动从 0x08000000 取第一条指令|
|启动代码（Startup）|外部写|初始化堆栈、跳转 main()|
|向量表（Vector Table）|外部写|告诉 CPU 哪里是 Reset_Handler、HardFault 等|

出厂基本的最小"电脑"硬件已经具备了，并有一个最小的指令操作系统。

最小系统运行原理：

    上电瞬间：
    1. 硬件复位 → PC = FLASH 地址 0x08000004
    2. 取 [0x08000004] 的值 → 这是 Reset_Handler 地址
    3. 跳转到 startup_stm32f103xb.s 中的 Reset_Handler
    4. 执行：
       - 设置堆栈指针（MSP）
       - 调用 SystemInit() → 打开 PLL，系统时钟 72MHz
       - 复制 .data 到 SRAM
       - 清零 .bss
       - 跳转到 main()
    5. main() 开始运行你的代码

## 启动模式
关于STM32F103C8T6的Boot0,Boot1的三个模式:

|BOOT1|BOOT0|启动区域|存储介质|映射地址|是否支持调试|用途说明|
|----|----|----|----|----|---|----|
|x|0|主闪存 (Main Flash)|64KB 用户 Flash（F103C8T6）|0x0800 0000|支持|- 正常程序运行（99% 项目）<br>- CubeIDE 下载、J-Link 调试|
|0|1|系统存储器 (System Memory)|ST 出厂烧录的 只读 ROM（约 2KB）|0x1FFF F000|不支持(只能烧录)|内置 Bootloader（串口/USB DFU(Device Firmware Upgrade)设备固件升级 下载）|
|1|1|内置 SRAM (Embedded SRAM)|20KB 内置 SRAM|0x2000 0000|支持(高级调试)|-调试/烧录/临时运行（无 Flash）<br>常用于:<br>1. Flash 被锁死时临时运行<br>2. 调试加密程序（不写 Flash）<br>3. IAP 双区切换（运行区在 SRAM）|


        BOOT0 = 0 → Flash 跑程序（日常）
        BOOT0 = 1 + BOOT1 = 0 → 串口 ISP 下载（救砖）
        BOOT0 = 1 + BOOT1 = 1 → SRAM 临时运行（调试）
        

调试说明(以STM32F103C8T6为例，不同芯片接线不同)：

|启动模式|是否支持 J-Link / ST-Link 调试？|接线|工具|说明|
|---|---|---|---|---|
|主Flash启动|支持|SWD (4线)/JTAG|CubeIDE / Programmer|正常调试模式，程序烧录到 Flash，断电不丢，支持断点、单步、变量查看。|
|SRAM 启动|支持|SWD (4线)/JTAG|CubeIDE / Programmer|程序加载到 SRAM，断电丢失，但可用于 Flash 程序损坏或加密时的临时调试。|
|系统存储器启动（ISP:In-System Programming)|不支持|串口（PA9/PA10）|STM32CubeProgrammer|运行 ST 内置 Bootloader，无法下断点，只能烧录，不能调试。|



Bootloader 地址是刷基本系统出厂程序包的地方，即可以理解为启动盘程序代码，即出厂就有一个基本的系统能统一管理和控制相应的GPIO等脚的功能，如最基本的PA9,PA10 。

如果bootloader 引导程序坏了，则所有引脚功能都不能正常使用了，此时可以理解为CPU不工作了。此刻只能到官方下载对应的启动程序[刷机程序]使用STM32CubeProgramme<font color="red">手动修改地址写到0x1FFF F000</font>,如果没改地址默认还是会把程序烧录到Flash 区上了。

## 救砖
意思非程序情况下原来烧录的程序死机或出故障了，不重新烧录就再也用不了了变成了砖头了。

**不用担心**烧录自己的程序里会损坏Bootloader区。
正常情况下，无论那一种Boot模式，随便烧录都不会把Bootloader的启动区给复盖了，只有专们修改写入地址为0x1FFF F000 才会复盖。如果不小心真的复盖损坏了，就到官网下载启动刷机程序如：STM32F103C8_SystemMemory.hex 进行手动选址烧录到0x1FFF F000 即可。

        Bootloader 刷废别慌张，  
        PA9 PA10 全白搭！  
        SWD 四线来救命，  
        ST-Link 直写 Flash，  
        0x1FFFF000 刷回去， CubeProgrammer → Start Address = 0x1FFFF000 
        串口 ISP 又复活！


如果你的程序在设计中占用了SWD或JTAG原本的PIn脚，重用成了其它GPIO时，此时就不能通过SWD或JTAG的方式进行烧录程序了，这就是为什么如果原来占用SWD/JTAG的PIN脚用作其它功能时，程序跑飞或损坏不能正常工作时，就可以通过串口的方式烧录，即把Boot模式改到Bootloader下，通过PA9和PA10进行烧录。就可以实现"救砖操作"