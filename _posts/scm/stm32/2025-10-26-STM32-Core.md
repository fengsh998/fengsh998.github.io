---
layout: post
title: "STM32-系统架构和存储器映射"
categories: STM32
tags: 单片机
author: fengsh998
typora-root-url: ..
---

# 阅读手册

Datasheet手册：必读，有对该芯片的内核，寄存器，闪存，外设，及各个Pin脚的作用，复用等说明。
参考手册：这个是寄存器开发必须要看的，包括总线架构，内存映射，寄存器说明。


## **系统架构图：**
![img](/assets/articles/ic/stm32/core/stm-core.jpg)

**ICode BUS:** 该总线连接 Cortex®-M3 内核的指令总线和闪存指令接口。

**DCode BUS:** 该总线将 Cortex®-M3 内核的 D​​Code 总线（用于加载和调试访问）连接到闪存数据接口。

**System BUS:** 该总线将 Cortex®-M3 内核的系统总线（外设总线）连接到 BusMatrix，BusMatrix 管理内核和 DMA 之间的仲裁。

**DMA BUS:** 该总线将 DMA 的 AHB 主接口连接到 BusMatrix，BusMatrix 管理 CPU,DCode 和 DMA 对 SRAM、闪存和外设的访问。

**BusMatrix:** 总线矩阵 (BusMatrix) 管理核心系统总线和 DMA 主总线之间的访问仲裁。仲裁采用轮询算法。在连接线设备中，总线矩阵由五个主设备（CPU DCode、系统总线、以太网 DMA、DMA1 和 DMA2 总线）和三个从设备（FLITF、SRAM 和 AHB2APB 桥接器）组成。在其他设备中，总线矩阵由四个主设备（CPU DCode、系统总线、DMA1 总线和 DMA2 总线）和四个从设备（FLITF、SRAM、FSMC 和 AHB2APB 桥接器）组成。AHB 外设通过总线矩阵连接到系统总线，以实现 DMA 访问。

**AHB(Advanced High-performance Bus):** 高级高性能总线

**APB(Advanced Peripheral Bus):** 高级外设总线

从架构图中可以看出各个总结可访问的闪存，外设的情况。

## **地址映射：**

程序存储器、数据存储器、寄存器和 I/O 端口都组织在同一个线性 4 GB 地址空间内。

可寻址内存空间被划分为 8 个主块，每个块 512 MB。字节以小端序格式编码在内存中。字中编号最小的字节被视为该字的最低有效字节，编号最大的字节被视为最高有效字节。

STM32 即32位处理器，按1字节=8位，所以32位则可分为4字节 因此有：

        高位                               低位
        1111 1111 1111 1111 1111 1111 1111 1111 == 刚好32位 最值为2^32-1 = 4G
    0x  F    F    F    F    F    F    F    F    == 0xFFFFFFFF 


STM32 的 4GB 地址空间被统一划分为 8 个主要的 512 MB (0x2000 0000) 大块。4GB的存储空间。每一位内存地址可存放1字节(8bit)大小的内容。

|序号|块|起始地址|结束地址|容量|主要作用|
|---|--|---|---|---|---|
|0|代码区(Code)|0x0000 0000|0x1FFF FFFF|512M|程序存储区。 CPU 从这里取指令。最关键的子区域有：<br>• 启动地址 (Boot Memory)：0x0000 0000 (重映射地址，实际指向 Flash 或 SRAM)。<br>• 片内 Flash：通常从 0x0800 0000 开始，用于存储用户程序代码和常量。|
|1|静态RAM(SRAM)|0x2000 0000|0x3FFF FFFF|512M|数据存储区。 读写速度快。主要存放：<br>• 片内 SRAM：从 0x2000 0000 开始，用于存放程序变量、堆 (Heap) 和栈 (Stack)。|
|2|外设区(Peripheral)|0x4000 0000|0x5FFF FFFF|512M|片内外设控制区（APB/AHB）。 存放所有片上外设的控制寄存器。如 GPIO、USART、TIMERS、SPI、CRC 等。读写这个区域的地址就是操作硬件。|
|3-4|外部存储器|0x6000 0000|0x9FFF FFFF|1G|外部设备存储区。 用于连接外部存储器或设备，如：<br>• FMC/FSMC (外部存储器控制器)：用于连接外部 SRAM、SDRAM、NAND Flash、NOR Flash 等。|
|5-6|外部设备I/O|0xA000 0000|0xDFFF FFFF|1G|外部设备 I/O 区。 用于连接外部 I/O 设备或特殊接口。|
|7|PPB系统专用区|0xE000 0000|0xE00F FFFF|1M|系统存储器 (System Memory)：包含用于芯片启动的 Bootloader 代码（只读）。|
|7|PPB系统专用区|0xE010 0000|0xFFFF FFFF|511M|内核私有外设总线 (PPB)。 专用于访问 ARM Cortex-M 内核自带的组件，如：<br>• NVIC (中断控制器)<br>• SysTick (系统滴答定时器)<br>• SCB (系统控制块) 和调试寄存器。|

内存映射主要给出了外设区的寄存器说明。

![img](/assets/articles/ic/stm32/core/memory-map.svg)

嵌入式闪存说明：

|寄存器名称|地址范围 (Base: 0x4002 2000)|作用 (Function)|
|----|----|-----|
|**FLASH_ACR**|	0x00 - 0x03 (4 字节)	|访问控制寄存器 (Access Control Register)：用于配置 Flash 存储器的访问参数，主要是设置等待周期 (Latency) 和使能预取缓冲区 (Prefetch Buffer)。这对于确保 CPU 在高速运行时能正确访问 Flash 是至关重要的。|
|**FLASH_KEYR**|	0x04 - 0x07 (4 字节)	|密钥寄存器 (Key Register)：用于解锁 (Unlock) Flash 控制寄存器 (FLASH_CR)。在执行擦除或编程操作之前，必须按顺序写入特定的密钥值来解锁 Flash 接口。|
|**FLASH_OPTKEYR**|	0x08 - 0x0B (4 字节)	|选项字节密钥寄存器 (Option Byte Key Register)：用于解锁选项字节 (Option Bytes) 的编程功能。选项字节用于配置芯片的保护设置、启动模式等。|
|**FLASH_SR**|	0x0C - 0x0F (4 字节)|	状态寄存器 (Status Register)：用于指示 Flash 操作的当前状态。包括操作是否完成、操作是否失败（错误标志），以及是否处于忙碌状态 (Busy 标志)。通过检查此寄存器可以确保编程或擦除操作安全完成。|
|**FLASH_CR**|	0x10 - 0x13 (4 字节)	|控制寄存器 (Control Register)：Flash 操作的核心控制中心。 用于设置和启动编程 (Program)、页擦除 (Page Erase)、整片擦除 (Mass Erase) 等操作。它还包含设置选项字节的位。|
|**FLASH_AR**|	0x14 - 0x17 (4 字节)	|地址寄存器 (Address Register)：在执行编程或页擦除操作时，用于指定要操作的目标地址。|
|**Reserved**|	0x18 - 0x1B (4 字节)	|保留：这是保留地址空间，不可用于软件读写。|
|**FLASH_OBR**|	0x1C - 0x1F (4 字节)	|选项字节寄存器 (Option Byte Register)：用于读取当前配置的选项字节值，如读保护状态、写保护状态、软件/硬件看门狗配置等。|
|**FLASH_WRPR**|	0x20 - 0x23 (4 字节)	|写保护寄存器 (Write Protect Register)：用于指示 Flash 存储器中哪些页（或扇区）被配置了写保护。通过设置写保护，可以防止代码或数据被意外擦除或修改。|


要对 STM32 的内部 Flash 进行编程（写入数据），通常需要遵循以下步骤，这体现了上述寄存器的协作关系：

解锁： 写入特定的密钥序列到 FLASH_KEYR。

配置操作： 设置 FLASH_CR 中的控制位，例如启用编程模式。

指定地址： 写入目标地址到 FLASH_AR。

写入数据： 将数据写入到 Flash 存储器的目标地址（通常是一个对齐的地址）。

等待完成： 检查 FLASH_SR 中的 Busy 标志，等待操作完成。

检查状态： 检查 FLASH_SR 中的错误标志，确保操作成功。

这些寄存器是您在进行 STM32 固件升级 (IAP) 或需要对内部 Flash 进行任何修改时，必须操作的硬件接口。


## RCC（Reset and Clock Control）- 复位与时钟控制

**配置 RCC 是编写任何 STM32 应用程序的第一步**，因为它决定了 CPU 和所有外设的工作速度和状态。(如果不配置，将默认使用内部时钟源，要看芯片是否带有)

**时钟源配置 (Clock Source Configuration):**
  
  选择和配置芯片的主时钟源，包括：
* HSE (High-Speed External)：高速外部晶振（如 8 MHz 或 25 MHz）。
* HSI (High-Speed Internal)：高速内部 RC 振荡器（固定频率，如 16 MHz）。
* LSE (Low-Speed External)：低速外部晶振（通常为 32.768 kHz，用于 RTC）。
* LSI (Low-Speed Internal)：低速内部 RC 振荡器。

 时钟分配和分频 (Clock Distribution and Prescaling):
* 控制时钟信号通过 PLL (锁相环) 进行倍频，以生成系统所需的高频时钟 (SYSCLK)。
* 配置分频器（Prescalers），将 SYSCLK 分配给不同的总线（如 AHB, APB1, APB2）和外设，确保它们以正确的速度运行。

外设时钟使能 (Peripheral Clock Enable):
* 控制各个片内外设（如 GPIO, USART, SPI, 定时器, DMA, CRC 等）的时钟开关。只有打开了某个外设的时钟，该外设才能工作。

复位控制 (Reset Control):
* 管理芯片和各个外设的复位操作，包括上电复位 (POR)、引脚复位、看门狗复位等，并记录复位状态。

**<font color="red">以STM32F103C8T6为例：</font>**
* 外部晶振 (HSE) 频率： 8 MHz（这是 F103 系列常用的外部晶振频率）。
* 目标系统时钟 (SYSCLK) 频率： 72 MHz（F103 系列的最高频率）。

|时钟|目标频率|分频/倍频配置|说明|
|---|---|----|---|
|HSE|8 MHz|-|外部高速晶振|
|PLL Source|8 MHz|8 MHz/1=8 MHz|F103 系列可选 HSE 或 HSE/2|
|PLL Multiplication (PLLMUL)|72 MHz|	×9|	8 MHz×9=72 MHz|
|SYSCLK (HCLK)|72 MHz|HPRE / 1|系统主时钟|
|PCLK2|72 MHz|PPRE2 / 1|连接 APB2 总线，允许 72 MHz|
|PCLK1|36 MHz|PPRE1 / 2|连接 APB1 总线，最高只能 36 MHz|

**外部系统时钟配置：**

8MHz高速的外部晶振，最大72MHz的的系统时钟

```c
// =================================================================
// 1. 内存基地址定义
// =================================================================

// 外设总线基地址
#define PERIPH_BASE           ((unsigned int)0x40000000)

// AHB 总线基地址
#define AHB_PERIPH_BASE       (PERIPH_BASE + 0x20000)

// 闪存接口 (FLASH) 寄存器基地址
#define FLASH_R_BASE          (AHB_PERIPH_BASE + 0x2000)
#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)

// RCC (复位与时钟控制) 寄存器基地址
#define RCC_BASE              (AHB_PERIPH_BASE + 0x1000)
#define RCC                 ((RCC_TypeDef *) RCC_BASE)


// =================================================================
// 2. 寄存器结构体定义 (简化版本，仅包含需要的寄存器)
// 因为unsigned int 刚好4字节即32位，正好是一个寄存器的大小
// =================================================================

// FLASH 接口寄存器结构体
typedef struct {
    volatile unsigned int ACR;      // 0x00: Flash 访问控制寄存器
    volatile unsigned int KEYR;
    volatile unsigned int OPTKEYR;
    volatile unsigned int SR;
    volatile unsigned int CR;
    volatile unsigned int AR;
    volatile unsigned int RESERVED;
    volatile unsigned int OBR;
    volatile unsigned int WRPR;
} FLASH_TypeDef;

// RCC 寄存器结构体(由低位往高位排列，注意顺序不能调换)
typedef struct {
    volatile unsigned int CR;       // 0x00: 时钟控制寄存器
    volatile unsigned int CFGR;     // 0x04: 时钟配置寄存器
    volatile unsigned int CIR;
    volatile unsigned int APB2RSTR;
    volatile unsigned int APB1RSTR;
    volatile unsigned int AHBENR;
    volatile unsigned int APB2ENR;  // 0x18: APB2 外设时钟使能寄存器
    volatile unsigned int APB1ENR;
    volatile unsigned int BDCR;
    volatile unsigned int CSR;
} RCC_TypeDef;


// =================================================================
// 3. 位定义宏
// =================================================================

// RCC_CR (时钟控制寄存器)
#define RCC_CR_HSEON            ((unsigned int)0x00010000)      // HSE 启用
#define RCC_CR_HSERDY           ((unsigned int)0x00020000)      // HSE 就绪
#define RCC_CR_PLLON            ((unsigned int)0x01000000)      // PLL 启用
#define RCC_CR_PLLRDY           ((unsigned int)0x02000000)      // PLL 就绪

// FLASH_ACR (访问控制寄存器)
#define FLASH_ACR_LATENCY_Pos   0
#define FLASH_ACR_LATENCY_MASK  ((unsigned int)0x00000007)      // 延时位掩码
#define FLASH_ACR_LATENCY_2WS   ((unsigned int)0x00000002)      // 2 个等待周期 (2WS)
#define FLASH_ACR_PRFTBE        ((unsigned int)0x00000010)      // 预取缓冲区使能

// RCC_CFGR (时钟配置寄存器)
#define RCC_CFGR_HPRE_DIV1      ((unsigned int)0x00000000)      // AHB 不分频
#define RCC_CFGR_PPRE1_DIV2     ((unsigned int)0x00000400)      // APB1 分频 2
#define RCC_CFGR_PPRE2_DIV1     ((unsigned int)0x00000000)      // APB2 不分频 (默认)

#define RCC_CFGR_PLLSRC_HSE     ((unsigned int)0x00010000)      // PLL 源选择 HSE
#define RCC_CFGR_PLLMUL_Msk     ((unsigned int)0x003C0000)      // PLL 倍频系数掩码
#define RCC_CFGR_PLLMUL9        ((unsigned int)0x001C0000)      // PLL 倍频 x9 (72MHz)

#define RCC_CFGR_SW_PLL         ((unsigned int)0x00000002)      // 系统时钟源选择 PLL
#define RCC_CFGR_SWS_PLL        ((unsigned int)0x00000008)      // 系统时钟切换状态为 PLL
#define RCC_CFGR_SW_Msk         ((unsigned int)0x00000003)      // 系统时钟选择掩码
#define RCC_CFGR_SWS_Msk        ((unsigned int)0x0000000C)      // 系统时钟切换状态掩码
```

```c
void SetSysClockTo72MHz_Custom(void)
{
    // =================================================================
    // 步骤 1: 启用 HSE 并等待稳定
    // =================================================================
    RCC->CR |= RCC_CR_HSEON;
    while (!(RCC->CR & RCC_CR_HSERDY));
    
    // =================================================================
    // 步骤 2: 配置 Flash 访问延时（2WS）和预取
    // =================================================================
    // 清除旧延时并设置 2WS
    FLASH->ACR &= ~FLASH_ACR_LATENCY_MASK;
    FLASH->ACR |= FLASH_ACR_LATENCY_2WS;
    // 启用预取缓冲区
    FLASH->ACR |= FLASH_ACR_PRFTBE;
    
    // =================================================================
    // 步骤 3: 配置总线分频器 (HCLK=72, PCLK1=36, PCLK2=72)
    // =================================================================
    // 清除相关分频位
    RCC->CFGR &= ~(0xF000 | 0x3800 | 0x07C0);
    
    // AHB 分频: /1 (HPRE=0x0)
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1; 
    
    // APB2 分频: /1 (PPRE2=0x0)
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV1; 
    
    // APB1 分频: /2 (PPRE1=0x4)
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
    
    // =================================================================
    // 步骤 4: 配置 PLL 参数 (HSE * 9 = 72MHz)
    // =================================================================
    // 清除 PLL 源和倍频系数
    RCC->CFGR &= ~(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMUL_Msk);

    // PLL 源: HSE (8 MHz)
    RCC->CFGR |= RCC_CFGR_PLLSRC_HSE;
    
    // PLL 倍频: x9 (72 MHz)
    RCC->CFGR |= RCC_CFGR_PLLMUL9;
    
    // =================================================================
    // 步骤 5: 启动 PLL 并等待稳定
    // =================================================================
    RCC->CR |= RCC_CR_PLLON;
    while (!(RCC->CR & RCC_CR_PLLRDY));
    
    // =================================================================
    // 步骤 6: 将系统时钟源切换到 PLL
    // =================================================================
    // 设置 SW 位选择 PLL
    RCC->CFGR &= ~RCC_CFGR_SW_Msk;
    RCC->CFGR |= RCC_CFGR_SW_PLL;

    // 等待切换完成
    while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_PLL);
}
```

SetSysClockTo72MHz_Custom可以在main中调用，也可以放在CMSIS风格的SystemInit()函数中调用。其中SystemInit()是在.s的启动文件中生成的。

CMSIS(Cortex Microcontroller Software Interface Standard):	Cortex 微控制器软件接口标准

|场景|调用位置|	优点|缺点|
|---|---|---|---|
|标准（CMSIS 风格）|汇编启动文件调用 SystemInit()（C 代码）|时序最精确，确保所有 C 代码运行在 72 MHz 下|	需要修改或配合启动汇编文件|
|简化（main 风格）|main() 函数的开头|最简单，所有代码都在 C 语言环境中。|main() 之前的所有初始化代码（如全局变量初始化）仍运行在默认的低速时钟下。|

**RTC(real-time Contorl)实时时钟配置：**

通常由32.768KHz的外部晶振驱动。LSE 的控制主要集中在 备份域寄存器 (Backup Domain Register) 中，因此配置前需要先启用对备份域的写权限。

{% highlight c linenos %}
// =================================================================
// 1. 备份域寄存器宏定义补充
// =================================================================

// PWR (电源控制) 寄存器基地址
#define PWR_BASE              (PERIPH_BASE + 0x7000)
#define PWR                 ((PWR_TypeDef *) PWR_BASE)

// RCC BDCR 寄存器在 RCC 结构体中已经定义 (0x20)
// RCC_TypeDef 结构体已经包含 BDCR 成员

// PWR 寄存器结构体 (简化)
typedef struct {
    volatile unsigned int CR;       // 0x00: 控制寄存器
    volatile unsigned int CSR;      // 0x04: 控制/状态寄存器
} PWR_TypeDef;


// =================================================================
// 2. 位定义宏补充
// =================================================================

// RCC_APB1ENR (APB1 外设时钟使能寄存器) - 用于开启 PWR 时钟
#define RCC_APB1ENR_PWREN       ((unsigned int)0x10000000)      // PWR 时钟使能

// PWR_CR (电源控制寄存器)
#define PWR_CR_DBP              ((unsigned int)0x00000100)      // 启用备份域写保护

// RCC_BDCR (备份域控制寄存器)
#define RCC_BDCR_LSEON          ((unsigned int)0x00000001)      // LSE 启用
#define RCC_BDCR_LSERDY         ((unsigned int)0x00000002)      // LSE 就绪
#define RCC_BDCR_LSEBYP         ((unsigned int)0x00000004)      // LSE 旁路 (如果使用外部时钟源)
#define RCC_BDCR_RTCSEL_LSE     ((unsigned int)0x00000100)      // RTC 时钟源选择 LSE
#define RCC_BDCR_RTCEN          ((unsigned int)0x00008000)      // RTC 时钟使能
#define RCC_BDCR_BDRST          ((unsigned int)0x00010000)      // 备份域复位
{% endhighlight %}


```c
/**
 * @brief 配置和启用 LSE 32.768kHz 晶振
 * */
void Configure_LSE_32K768(void)
{
    // =================================================================
    // 步骤 1: 启用备份域写权限
    // =================================================================
    
    // 1.1 启用 PWR 时钟
    // APB1ENR 寄存器地址: RCC_BASE + 0x1C
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
    
    // 1.2 启用备份域写访问保护 (DBP - Disable Backup Protection)
    // 写入 DBP 位，允许对 RTC/备份寄存器进行写操作
    PWR->CR |= PWR_CR_DBP; 
    
    
    // =================================================================
    // 步骤 2: 启用 LSE 振荡器
    // =================================================================
    
    // 2.1 清除备份域复位标志
    // 在某些情况下，可能需要先复位备份域 (可选，但推荐在配置前执行)
    // RCC->BDCR |= RCC_BDCR_BDRST; 
    // RCC->BDCR &= ~RCC_BDCR_BDRST; 
    
    // 2.2 启用 LSE (写入 LSEON 位)
    // 注意：如果有 RTCEN，需要先清除 RTCEN 和 RTCSEL，否则 LSEON 可能不起作用
    RCC->BDCR &= ~(RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_LSE);
    RCC->BDCR |= RCC_BDCR_LSEON;
    
    // 2.3 等待 LSE 稳定 (LSERDY)
    // LSE 稳定所需时间较长（可能几百毫秒），需要等待。
    while (!(RCC->BDCR & RCC_BDCR_LSERDY))
    {
        // 可以添加看门狗复位或低功耗等待
    }
    
    
    // =================================================================
    // 步骤 3: （可选）选择 LSE 作为 RTC 时钟源
    // =================================================================
    
    // 3.1 选择 LSE 作为 RTC 时钟源
    RCC->BDCR |= RCC_BDCR_RTCSEL_LSE;
    
    // 3.2 启用 RTC 时钟 (RTCEN)
    RCC->BDCR |= RCC_BDCR_RTCEN;
    
    
    // =================================================================
    // 步骤 4: 关闭备份域写保护 (推荐)
    // =================================================================
    
    // 配置完成后，禁用备份域写访问保护
    // 保护 RTC 寄存器不被意外修改
    // PWR->CR &= ~PWR_CR_DBP; 
}
```

**备份域保护 (DBP):** 由于 LSE 和 RTC 的状态必须在芯片上电后即使主电源丢失也能维持（通过备用电池供电），所以它们所在的寄存器位于“备份域”，受到写保护。操作前必须设置 PWR->CR 寄存器中的 DBP 位以解锁。

**LSEON/LSERDY:** 启用 LSEON 位后，必须等待 LSERDY 位变为 1，才能确认 32.768 kHz 晶振已稳定启动。

**RTC 时钟源:** 只有在 LSE 稳定后，您才能选择它作为 RTC 的时钟源 (RTCSEL) 并启用 RTC 时钟 (RTCEN)。



STM32 编程流程：
时钟 --> 使能 ---> 配置 ---> 操作




参考手册：
[【STM32Fx-RM0008】](https://www.st.com.cn/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf)